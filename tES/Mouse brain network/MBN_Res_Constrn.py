# -*- coding: utf-8 -*-
"""MBN_Res_Constrn

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k6_bmXQ1UOyzpzlmgAQBvlGzGNXZ2z09
"""

# processing.py (ES_Adaptive class definition)
import numpy as np
import networkx as nx

import sys
sys.path.append('../Model/tES/')
sys.path.append('./MouseBrainLib/')

# wrapper.py (Wrapper class and network creation)
import networkx as nx
from tES_Adaptive import tES_Adaptive
from DataUtils import DataUtils

class MBN_RC(tES_Adaptive, DataUtils):

    def __init__(self,
                 nepochs=10000,
                 dt=0.01,
                 lambda_o=0.01,
                 alpha=0.01,
                 beta=0.002,
                 plot_bifurcation=False,
                 epochs_per_lambda_o=10000,
                 step_size_lambda_o=0.003):

        DataUtils.__init__(self)

        self.nepochs = nepochs
        self.dt = dt
        self.lambda_o = lambda_o
        self.plot_bifurcation = plot_bifurcation
        self.epochs_per_lambda_o = epochs_per_lambda_o
        self.step_size_lambda_o = step_size_lambda_o
        self.alpha = alpha
        self.beta = beta

        self.initialize_mbn_network()

        tES_Adaptive.__init__(self,
                              self.A,
                              self.N,
                              self.lambda_o,
                              self.alpha,
                              self.beta,
                              self.nepochs,
                              self.dt,
                              self.plot_bifurcation,
                              self.epochs_per_lambda_o,
                              self.step_size_lambda_o)

    def initialize_mbn_network(self):
        self.N = self.N_REGIONS_WHOLE_BRAIN
        self.A = np.zeros([self.N, self.N])
        self.A[:] = self.WHOLE_BRAIN_CONN
        self.A = np.mat(self.A)

        # Create graph object from adjacency matrix
        self.G = nx.from_numpy_array(self.A)
        self.avg_degree = (sum(dict(self.G.degree()).values())/self.N)
        self.A = np.mat(nx.adjacency_matrix(self.G).todense())
        np.fill_diagonal(self.A, 0)

        print("Average shortest path length: ", nx.average_shortest_path_length(self.G))
        print("Avg clustering coefficient: ", nx.average_clustering(self.G))

    def run_model(self):
        tES_Adaptive.run_model(self)

    #Function to compute transition count
    def transition_count(self):
        x=self.GLOBAL_ORDER_VERBOSE
        i=0
        self.tCount=[]
        t_Count=0
        while i<len(x):
          while i<len(x)-1 and x[i]>=x[i+1]:
            i+=1
          unsync=i
          while i<len(x)-1 and x[i]<=x[i+1]:
            i+=1
          sync=i
          if unsync<sync:
            t_Count+=1
            self.tCount.append((sync,unsync))
          i+=1
        print("Total transitions:", t_Count)

    #Function to compute transition time
    def transition_time(self):
        tCount=self.tCount
        self.tTime=[]
        tNo=0
        for i in tCount:
          sync,unsync=i
          t_Time=sync-unsync
          tNo+=1
          self.tTime.append(t_Time)
          print(f"Transition Time for Transition {tNo}: {t_Time:.2f} sec")
        print()
        t_avg=sum(self.tTime)/tNo
        print(f"Average transition time:{t_avg:.2f} sec")